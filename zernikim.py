# -*- coding: utf-8 -*-
"""ZM_code.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V5iVbQoy_E1MRzpTBQlx_B2oNhzo-8_j

### **Zernike Moments - Astronomical and none-astronomical images**

This code calculates Zernike moments for astronomical images. Zernike moments are unique due to orthogonality and a complete set of Zernike polynomials. Zernike moments are used in image analysis to characterize the shape and structure of objects. The following articles and their references give a detailed description of the Zernike polynomials and Zernike moments.

[Raboonik, A., Safari, H., Alipour, N., & Wheatland, M. S. 2017, ApJ, 834, 11
](https://iopscience.iop.org/article/10.3847/1538-4357/834/1/11/meta)

[Alipour, N., Mohammadi, F., Safari, H. 2019, ApJS, 243, 20](https://iopscience.iop.org/article/10.3847/1538-4365/ab289b/meta)

---
The code includes the following functions:
1. zernike_order_list: Generates a list of Zernike polynomial orders.
2. robust_fact_quot: Calculates the robust factor quotient between two lists of values.
3. zernike_bf: Generates Zernike basis functions for a given size and order.
4. zernike_mom: Calculates the Zernike moments of an input image using precomputed Zernike basis functions.
5. zernike_rec: Reconstructs an image from Zernike moments(Inverse trasformation).

- The zernike_order_list function calculates factorials, p-indices, and q-indices for Zernike polynomials.
- The robust_fact_quot function removes common elements from lists and calculates product quotients.
- The zernike_bf function generates Zernike basis functions stored in a complex-valued grid.
- The zernike_mom function calculates Zernike moments by summing the product of the image and basis functions.
- The zernike_rec function reconstructs an image by summing the weighted Zernike basis functions based on moments.
- The code utilizes additional helper functions, mathematical calculations, and NumPy operations.
- The functions accept parameters such as image data, maximum order, size, and optional arguments.
- The code includes checks for data validity, such as square image size matching, and prints informative error messages.
- The functions return relevant results, such as Zernike moments or reconstructed images.

Authors: [Hamed Ghaderi](https://github.com/hmddev1), Nasibe Alipour, Pardise Garavand, [Hosein Safari](https://github.com/safarihossein)

**Importing libraries:**
"""

# Commented out IPython magic to ensure Python compatibility.
import os
import math
import glob
import cv2
import numpy as np
from PIL import Image
import pandas as pd
from numpy.linalg import lstsq, matrix_rank, norm
import matplotlib.pyplot as plt
# %matplotlib inline
import astropy
from astropy.io import fits
from astropy.visualization import astropy_mpl_style
plt.style.use(astropy_mpl_style)
from astropy.utils.data import get_pkg_data_filename
import astropy.io.fits.header
from astropy.visualization import (MinMaxInterval, SqrtStretch,ImageNormalize)
from matplotlib.colors import LogNorm

"""**Order list func.:**"""

def zernike_order_list(order,*withneg):
    """
    Generates a list of Zernike polynomial orders for a given maximum order.

    Parameters:
    - order (int): The maximum order of Zernike polynomials to be included.
    - *withneg (optional): Additional parameter to include negative Zernike orders. Default is 0.

    Returns:
    - F (list): List of factorials for each order up to the maximum order.
    - P (list): List of p-indices for each Zernike polynomial order.
    - Q (list): List of q-indices for each Zernike polynomial order.

    Note:
    - The generated list includes both positive and negative Zernike orders by default.
    - If the *withneg parameter is provided with any value, only positive orders are generated.

    """
    # Calculate the total number of input arguments
    args =zernike_order_list.__code__.co_argcount
    nargin =args + len(withneg)

    # Determine if negative orders should be included
    if nargin < 2:
       withneg = 0
    else:
       withneg = np.array(withneg)

    # Initialize lists for factorials, p-indices, and q-indices
    F = []
    for i in range(0, order+1):
        F.append(math.factorial(i))
    P = []
    Q = []

    # Generate Zernike orders based on the provided arguments
    if withneg == 1:
        for p in range(0, order+1):
            for q in range(-p, p+1):
                if (abs(p - q) % 2) == 0:
                    P.append(p)
                    Q.append(q)
    else:
        for p in range(0, order+1):
            for q in range(0, p+1):
                if (abs(p - q) % 2) == 0:
                    P.append(p)
                    Q.append(q)

    # Return the generated lists of factorials, p-indices, and q-indices
    return F,P,Q

"""**Robust fact quot func.:**"""

def robust_fact_quot(X,Y):

      """
        Calculates the robust factor quotient between two lists, X and Y.
        Parameters:
        - X (list): First list of values.
        - Y (list): Second list of values.

        Returns:
        - R (float): Robust factor quotient.

        Note:
        - The function removes common elements from X and Y, calculates the product quotient between the remaining values, and returns the robust factor quotient.

      """
      # Remove common elements from X and Y
      ca = np.unique(X)
      for k in range(len(ca)):
          i1,=np.where(X==ca[k])
          i2,=np.where(Y==ca[k])
          m=min(len(i1),len(i2))
          if m!=0:
            nn=X[i1[0]]
            X.remove(nn)
            Y.remove(nn)

      # Calculate the robust factor quotient
      R=1
      l1=len(X)
      l2=len(Y)
      for k in range(0,min(l1,l2)):
            R=R*X[k]/Y[k]
      for k in range(l2,l1):
            R=R*X[k]
      for k in range(l1,l2):
            R=R/Y[k]
      return R

"""**bf func.:**"""

def zernike_bf(SZ, order, *withneg):
  """
    Generates Zernike basis functions for a given size, order, and optional withneg parameter.

    Parameters:
    - SZ (int): Size of the Zernike basis functions grid.
    - order (int): Maximum order of Zernike polynomials to be included.
    - *withneg (optional): Additional parameter to include negative Zernike orders. Default is 0.

    Returns:
    - ZBFSTR (object): An object that encapsulates the Zernike basis functions data.

    Note:
    - This function generates Zernike basis functions using the provided size, order, and optional withneg parameter.
    - The Zernike basis functions are stored in a complex-valued grid of size (SZ, SZ, length), where length represents the number of Zernike polynomials.
    - The ZBFSTR object contains information about the maximum order, orders, indices, and the Zernike basis functions grid.

  """

  # Calculate the total number of input arguments
  args =zernike_bf.__code__.co_argcount
  nargin =args + len(withneg)

  # Determine the value of the withneg parameter
  if nargin < 3:
       withneg = 0
  else:
       withneg = 1

  # Perform Zernike order list calculation
  limitfastcomp = 50
  F,P,Q = zernike_order_list(order,withneg)
  length = len(P)
  szh = SZ / 2
  s=(1 + (2 * order), 1 + (2 * order))
  pqind = (-1) * (np.ones(s))
  src1 = (1 + order) + np.array(P)
  src2 = (1 + order) + np.array(Q)
  z = np.array([src1,src2])
  #s=np.ravel_multi_index(z-1,pqind.shape,order='F',mode=('clip'))
  z1=z[0]-1
  z2=z[1]-1
  for i in range(len(z1)):
      pqind[z1[i]][z2[i]]=i+1
  Rmns = np.zeros((1 + (2 * order), (1 + (2 * order)) + 1, 1 + (2 * order)))
  for flat in range(0 ,min(length, limitfastcomp)):
      m = P[flat]
      n = Q[flat]
      mpnh = math.floor((m + abs(n)) / 2)
      mmnh = math.floor((m - abs(n)) / 2)
      for s in range(0,mmnh+1):
        Rmns[order+m,order+n,s]=((-1) ** s) * F[m-s] / (F[s] * F[mpnh-s] * F[mmnh-s])
  for flat in range(limitfastcomp ,length):
      m = P[flat]
      n = Q[flat]
      mpnh = math.floor((m + abs(n)) / 2)
      mmnh = math.floor((m - abs(n)) / 2)
      for s in range(0,mmnh+1):
          X=[]
          Y=[]
          for i in range(1,m-s+1):
             X.append(i)
          for i in range(1,s+1):
             Y.append(i)
          for i in range(1,mpnh-s+1):
              Y.append(i)
          for i in range(1,mmnh-s+1):
              Y.append(i)
          Rmns[order+m,order+n,s]=((-1) ** s)*robust_fact_quot(X,Y)

  ZBF = np.zeros((SZ,SZ,length), dtype=complex)
  for y in range(1,SZ+1):
    for x in range(1,SZ+1):
        rho = math.sqrt(((szh - x) ** 2) + ((szh - y) ** 2))
        theta = math.atan2(szh - y, szh - x)
        if rho > szh:
              continue
        rho = rho / szh
        if theta < 0:
              theta = theta + (2 * np.pi)
        for flat in range(0,length):
            m = P[flat]
            n = Q[flat]
            R=0
            for s in range(0,int((m-abs(n))/2) +1):
              R=R+Rmns[order+m,order+n,s]*(rho**(m-2*s))
            ZBF[y-1,x-1,flat] = R*np.exp(n*theta*1j);
  pq = np.array([P,Q])
  class Zer:
    def __init__(self, ORDER, pq, pqind,ZBF,withneg):
       self.maxorder = ORDER
       self.withneg=withneg
       self.orders = pq
       self.index = pqind
       self.bf = ZBF

  ZBFSTR=Zer(order, pq, pqind,ZBF,withneg)
  return ZBFSTR

"""**Moment func.:**"""

def zernike_mom(I, ZBFSTR):
    """
    Calculates Zernike moments of an input image using precomputed Zernike basis functions.

    Parameters:
    - I (ndarray): Input image as a 2D NumPy array.
    - ZBFSTR (object): An object containing Zernike basis functions data.

    Returns:
    - Z (ndarray): Array of complex-valued Zernike moments.

    Note:
    - The input image must be square-shaped.
    - The ZBFSTR object should contain the necessary information about the Zernike basis functions.

    """
    # Check if the image is of square size
    if I.shape[0] != I.shape[1]:
        print("The image must be of square size!")

    # Extract necessary data from the ZBFSTR object
    bf = ZBFSTR.bf
    P  = ZBFSTR.orders[0]
    Q  = ZBFSTR.orders[1]
    Ind = ZBFSTR.index
    length = bf.shape[2]

    # Initialize an array for storing Zernike moments
    Z = np.zeros(length, dtype=complex)

    # Calculate Zernike moments
    for flat in range(0, length):
        m = P[flat]
        n = Q[flat]
        Z[flat] = ((m + 1) / np.pi) * (sum(sum((I * np.conj(bf[:,:,flat])))))

    return Z

"""**Recostruct func.:**"""

def zernike_rec(Z, SZ, ZBFSTR, *OPTSTARTIND):
    """
    Reconstructs an image from Zernike moments using precomputed Zernike basis functions.

    Parameters:
    - Z (ndarray): Array of complex-valued Zernike moments.
    - SZ (int): Size of the reconstructed image.
    - ZBFSTR (object): An object containing Zernike basis functions data.
    - *OPTSTARTIND (optional): Additional parameter to specify the starting index for reconstruction. Default is determined based on ZBFSTR.

    Returns:
    - I (ndarray): Reconstructed image as a 2D NumPy array.

    Note:
    - The function uses the provided Zernike moments and Zernike basis functions to reconstruct the image.
    - The ZBFSTR object should contain the necessary information about the Zernike basis functions.
    - If *OPTSTARTIND is not provided, it is determined automatically based on the ZBFSTR object.

    """

    # Extract necessary data from the ZBFSTR object
    length = len(Z)
    od = ZBFSTR.orders
    Ind = ZBFSTR.index
    bf = ZBFSTR.bf
    maxorder = ZBFSTR.maxorder
    Withneg = ZBFSTR.withneg

    # Determine the value of the OPTSTARTIND parameter
    args =zernike_rec.__code__.co_argcount
    nargin =args + len(OPTSTARTIND)

    if nargin < 4:
        if Withneg == 1:
            OPTSTARTIND = 3
        else:
            OPTSTARTIND = 2
    print(OPTSTARTIND)

    # Check if Zernike basis functions match the input vector
    if ZBFSTR.bf.shape[2] != length:
        print(ZBFSTR.bf.shape[2])
        print(length)
        print("**** ERROR *** in zernike_rec: Zernike basis functions do not match input vector!")

    # Initialize an array for the reconstructed image
    I = np.zeros((SZ,SZ), dtype=complex)

    # Reconstruct the image from Zernike moments
    if ZBFSTR.withneg:
        for i in range(OPTSTARTIND,length):
            I = I + (Z[i] * bf[:,:, i])
    else:
         for i in range(OPTSTARTIND,length):
            I = I + (Z[i] * bf[:,:, i])
            p = od[0,i]
            q = od[1,i]
            if q != 0:
                ieq = int(Ind[maxorder + p,maxorder + abs(q)]-1)
                if ieq < 1:
                    print("Invalid equivalent moment!")

                I =I + np.conj(Z[ieq]) * np.conj(bf[:,:,ieq])

    I = I.real      # Take the real part of the complex number

    # ai=im2bw(ai,0.5)
    #thresh = 128      #Define a threshold, 128 is the middle of black and white in grey scale.
    #I = cv2.threshold(I, thresh, 255, cv2.THRESH_BINARY)[1]           # Converts the grayscale image to binary image with level = 0.5!
    return I

"""
**Read multi files:**

Steps:

1.   Mount google drive
2.   Upload data on google drive
3.   Do functions on data
4.   Save zenrnike moments on text file *(For P=31 we must have 528 ZM for each data. For 250 galaxy data we have 132000 ZM)*
5.   Load the .txt file to show and plot data
"""

from google.colab import drive
drive.mount('/content/drive')

"""testing new data"""

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive/Zernike/efigi_new/Infrared/I_i/
path = r'/content/drive/MyDrive/Zernike/efigi_new/Infrared/I_i/*.fits'
files = glob.glob(path, recursive=True)
crop_images = []  # List to store cropped images

for n in files:
  image_file=get_pkg_data_filename(n)
  img=fits.getdata(image_file)
  # img=np.rot90(img, k=1)
  img = np.flip(img, axis=0)
  crop_image=img[75:175, 75:175]
  crop_images.append(crop_image)

print(type(crop_images))
print(len(crop_images))

plt.imshow(crop_images[100], cmap='gray')

ZBFSTR=zernike_bf(255,31,1)
def fun1(x,ZBFSTR):
    image_file = os.path.basename(x)
    image_data = fits.getdata(image_file)
    SZ=image_data.shape
    Z=zernike_mom(image_data, ZBFSTR)
    return  Z

d = np.zeros((len(crop_images), 528))
for n in range(len(crop_images)):
    image_path = files[n]  # Get the corresponding file path from 'files'
    d[n, :] = np.abs(fun1(image_path, ZBFSTR))